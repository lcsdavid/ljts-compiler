/* Tokens placés en ordre alphabétique pour mieux si retrouver. */
%token ASSIGNMENT CLASS
%token DEF ELSE EXTENDS
%token <std::string> IDENTIFIER 
%token IF
%token <int> INTEGER
%token IS NEW OBJECT OVERRIDE
%token <int> RELATIONAL_OPERATOR
%token RETURN
%token <std::string> STRING
%token THEN 
%token <std::string> TYPENAME
%token VAR

/* Declarations */
%type <std::vector<Type*>> LOptDecls LDecls
%type <Type*> Decl

/* Parameters */
%type <std::vector<Parameter>> LOptParamDecl LParamDecl
%type <Parameter> ParamDecl
%type <bool> OptVar

/* Classes */
%type <Class*> ClassDecl
%type <std::string> OptExtends

/* Objects */
%type <Object*> ObjectDecl

/* Fields */
%type <std::vector<Parameter>> LOptField LField
%type <Parameter> Field

/* Constructors */
%type <ClassConstructor> ClassConstructor
%type <ObjectConstructor> ObjectConstructor

/* Methods */
%type <std::vector<Method>> LOptMethod LMethod
%type <Method> Method
%type <bool> OptOverride
%type <std::string> OptReturn

/* Block */
%type <Block*> Block

/* Instructions */
%type <std::vector<Tree*>> LOptInst LInst
%type <Tree*> Inst

/* Declaration variable */
%type <std::vector<Parameter>> LOptVarDecl LVarDecl
%type <Parameter> VarDecl

/* Expressions */
%type <std::vector<Tree*>> LOptExpr LExpr
%type <Tree*> Expr

%{

#define YYDEBUG 1

#include "ljts-compiler.hpp"

void* program = nullptr;

%}
%define api.value.type union

%debug
%error-verbose

%right ASSIGNMENT
%right ELSE
%left RELATIONAL_OPERATOR
%left '+' '-'
%left '*' '/'
%nonassoc unary NEW
%left '.'

%%
Program : LOptDecls Block { /*program = new Program($1, $2);*/ }
;

LOptDecls : LDecls   { $$ = std::vector<Type*>($1); }
 |                   { $$ = std::vector<Type*>(); }
;

LDecls : Decl LDecls { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
 | Decl              { $$.push_back($1); }
;

Decl : ClassDecl     { $$ = $1; }
 | ObjectDecl        { $$ = $1; }
;

/* Parameter declaration */

LOptParamDecl : LParamDecl                 { $$ = $1; }
 |                                         { $$ = std::vector<Parameter>(); }
;

LParamDecl : ParamDecl ',' LParamDecl      { $$.push_back($1); $$.insert(std::end($$), std::begin($3), std::end($3)); }
 | ParamDecl                               { $$.push_back($1); }	
;

ParamDecl : OptVar IDENTIFIER ':' TYPENAME { $$ = Parameter($2, $4, $1); }
;

OptVar : VAR                               { $$ = true; }
 |                                         { $$ = false; }
;

/* ===== Class ===== */
/* Class(std::string const &, std::vector<Parameter*> const &, std::string *, std::vector<Parameter*> const &, ClassConstructor &, std::vector<Method*> const &); */

ClassDecl : CLASS TYPENAME '(' LOptParamDecl ')' OptExtends IS '{' LOptField ClassConstructor LOptMethod '}' { $$ = new Class($2, $4, $6, $9, $10, $11); }
;

OptExtends : EXTENDS TYPENAME	{ $$ = $2; }
 |								{ $$ = ""; }
;

ClassConstructor : DEF TYPENAME '(' LOptParamDecl ')' ':' TYPENAME '(' LOptExpr ')' IS Block	{ $$ = ClassConstructor($2, $4, $7, $9, $12); }
 | DEF TYPENAME '(' LOptParamDecl ')' IS Block													{ $$ = ClassConstructor($2, $4, "", std::vector<Tree*>(), $7); }
;

/* ===== Object ===== */

ObjectDecl : OBJECT TYPENAME IS '{' LOptField ObjectConstructor LOptMethod '}' { $$ = new Object($2, $5, $6, $7); }
;

ObjectConstructor : DEF TYPENAME IS Block                                      { $$ = ObjectConstructor($2, $4); }
;

/* ===== Champ ===== */

LOptField : LField                      { $$ = $1; }
|                                       { }
;

LField : Field LField                   { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
| Field                                 { $$.push_back($1); }  
;

Field : VAR IDENTIFIER ':' TYPENAME ';' { $$ = Parameter($2, $4); }
;

/* ===== Method ===== */

LOptMethod : LMethod	{ $$ = std::vector<Method>($1); }
 |						{ $$ = std::vector<Method>(); }
;

LMethod : Method LMethod	{ $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
 | Method					{ $$.push_back($1); }
;

Method : OptOverride DEF IDENTIFIER '(' LOptParamDecl ')' ':' TYPENAME ASSIGNMENT Expr { $$ = Method($1, $3, $5, $8, $10); }
 | OptOverride DEF IDENTIFIER '(' LOptParamDecl ')' OptReturn IS Block                 { $$ = Method($1, $3, $5, $7, $9); }
;

OptOverride : OVERRIDE                                                                 { $$ = true; }
 |                                                                                     { $$ = false; }
;

OptReturn : ':' TYPENAME                                                               { $$ = $2; }
 |                                                                                     { $$ = ""; }
;

/* ===== Instruction ===== */

LOptInst : LInst               { $$ = $1; }
 |                             { $$ = std::vector<Tree*>(); }
;

LInst : Inst LInst             { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
 | Inst                        { $$.push_back($1); }
;

Inst : Expr ';'                { $$ = $1; }
 | Block                       { $$ = new Tree(yylineno, inst_block, $1); }
 | RETURN ';'                  { $$ = new Tree(yylineno, return_call); }
 | Expr ASSIGNMENT Expr ';'    { $$ = new Tree(yylineno, assignment, { $1, $3 }); }
 | IF Expr THEN Inst ELSE Inst { $$ = new Tree(yylineno, if_then_else, { $2, $4, $6 }); }
;

/* Block */

Block : '{' LOptInst '}'        { $$ = new Block(std::vector<Parameter>(),$2);}
 | '{' LOptVarDecl IS LInst '}' { $$ = new Block($2, $4); }
;

/* Declaration variable */

LOptVarDecl : LVarDecl                                { $$ = $1; }
 |                                                    { $$ = std::vector<Parameter>();}
;

LVarDecl : VarDecl LVarDecl                           { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); } 
 | VarDecl                                            { $$.push_back($1); }
;

VarDecl : IDENTIFIER ':' TYPENAME ASSIGNMENT Expr ';' { $$ = Parameter($1, $3/*, $5*/); } 
 | IDENTIFIER ':' TYPENAME ';'                        { $$ = Parameter($1, $3); }
;

/* ===== Expression ===== */

LOptExpr : LExpr       { $$ = $1; }
|                      { $$ = std::vector<Tree*>(); }
;

LExpr : Expr ',' LExpr { $$.push_back($1); $$.insert(std::end($$), std::begin($3), std::end($3));  }
| Expr                 { $$.push_back($1); }
;

Expr : Expr RELATIONAL_OPERATOR Expr        { $$ = new Tree(yylineno, $2, { $1, $3 }); }
 | Expr '+' Expr                            { $$ = new Tree(yylineno, addition, { $1, $3 }); } 
 | Expr '-' Expr                            { $$ = new Tree(yylineno, substraction, { $1, $3 }); } 
 | Expr '*' Expr                            { $$ = new Tree(yylineno, multiplication, { $1, $3 }); }
 | Expr '/' Expr                            { $$ = new Tree(yylineno, division, { $1, $3 }); }
 | '+' Expr %prec unary                     { $$ = new Tree(yylineno, unary_plus, { $2 }); }
 | '-' Expr %prec unary                     { $$ = new Tree(yylineno, unary_substract, { $2 }); }
 | '(' TYPENAME Expr ')'                    { $$ = new Tree(yylineno, cast, { $2, $3 }); }
 | NEW TYPENAME '(' LOptExpr ')'            { $$ = new Tree(yylineno, instanciation, { $2, $4 });}
 | Expr '.' IDENTIFIER                      { $$ = new Tree(yylineno, member_access, { $1, $3 }); }
 | TYPENAME '.' IDENTIFIER                  { $$ = new Tree(yylineno, member_access, { $1, $3 }); }
 | Expr '.' IDENTIFIER '(' LOptExpr ')'     { $$ = new Tree(yylineno, method_call, { $1, $3, $5 }); }
 | TYPENAME '.' IDENTIFIER '(' LOptExpr ')' { $$ = new Tree(yylineno, method_call, { $1, $3, $5 }); }
 | '(' Expr ')'                             { $$ = $2; }
 | INTEGER                                  { $$ = new Tree(yylineno, integer, $1); }
 | STRING                                   { $$ = new Tree(yylineno, string, $1); }
 | IDENTIFIER                               { $$ = new Tree(yylineno, identifier, $1); }
;

%%

#ifdef BISON_MAIN

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <iostream>

int main(int argc, char **argv) {
	int fi;
	if ((fi = open(argv[1], O_RDONLY)) == -1) {
		std::cerr << "Erreur: fichier inaccessible " << argv[1] << std::endl;
		exit(1);
	}
	std::cout << "Fichier " << argv[1] << " chargé correctement." << std::endl;
	close(0); dup(fi); close(fi);
	if (yyparse() == 0) {
		std::cout << "Compilation succeed!" << std::endl;
		return 0;
	}
	return -1;
}

#endif