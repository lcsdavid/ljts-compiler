%token ASSIGNEMENT CLASS DEF ELSE EXTENDS IS IF NEW OBJECT OVERRIDE VAR RETURN THEN

%token <int> RELATIONAL_OPERATOR

%token <std::string> IDENTIFIER
%token <std::variant<int, double>> INTEGER

%{

#include "ljts-compiler.hpp"

extern "C" {
	int yylex();
}

void yyerror (char const *s) {
	fprintf (stderr, "%s\n", s);
}

%}

%right ASSIGNMENT
%right ELSE
%left RELATIONAL_OPERATOR
%left '+' '-'
%left '*' '/'
%nonassoc unary NEW
%left '.'

%%
ProgrammeComplet : Programme '$'
;

Programme : LOptDecls Bloc
;

LOptDecls : LDecls
|
;

LDecls : Decls ';' LDecls
| Decls
;

Decls : ClassDecl
| ObjectDecl
;

/*
LClassDecl : ClassDecl ';' LClassDecl
;

LObjectDecl : ObjectDecl ';' LObjectDecl
;
*/ 

/* Parameter declaration*/

LOptParamDecl : LParamDecl
|
;

LParamDecl : ParamDecl',' LParamDecl
| ParamDecl
;

ParamDecl : OptVar Identifier ':' Identifier
;

OptVar : VAR
|
;

/* ===== Class ===== */

ClassDecl : CLASS Identifier '(' LOptParamDecl ')' OptExtends IS '{' ClassDef '}'
;

OptExtends : EXTENDS Identifier
|
;

ClassDef : LOptField ClassConstructor LOptMethod
;

ClassConstructor : DEF Identifier '(' LOptParamDecl ')' OptSuper IS '{'Bloc'}'
;

OptSuper : Identifier '(' LOptParam ')'
|
;

/* ===== Object ===== */

ObjectDecl : CLASS Identifier IS '{' ObjectDef '}'
;

ObjectDef : LOptField ObjectConstructor LOptMethod
;

ObjectConstructor : DEF Identifier IS '{' Bloc '}'
;

/* ===== Champ ===== */

LOptField : LField
|
;

LField : Field LField
| Field
;

Field : VAR Identifier ':' Identifier ';'
;

/* ===== Method ===== */

LOptMethod : LMethod
 |
;

LMethod : Method LMethod
 | Method
;

Method : OptOverride Identifier '(' LOptParamDecl ')' Identifier ASSIGNMENT Expr
 | OptOverride Identifier '(' LOptParamDecl ')' OptReturn IS Bloc
;

OptOverride : OVERRIDE
 |
;

OptReturn : Identifier
 |
;

/* ===== Instruction ===== */

LOptInst : LInst
 |
;

LInst : Inst ';' LInst
 | Inst ';'
;

Inst : Expr
 | Bloc
 | RETURN
 | Expr ASSIGNMENT Expr
 | IF Expr THEN Inst ELSE Inst
;

Bloc : '{' LOptInst '}'
 | '{' LOptVarDecl IS LInst '}'
;

/* Declaration variable */

LOptVarDecl : LVarDecl
 |
;

LVarDecl : VarDecl LVarDecl
 | VarDecl
;

VarDecl : Identifier ':' Identifier ASSIGNMENT Expr
 | Identifier ':' Identifier
;

/* ===== Expression ===== */

Expr : Expr RELATIONAL_OPERATOR Expr {(Tree) {3, $1,$2, $3};}
 | Expr '+' Expr {(Tree) {3, $1, $2, $3};}
 | Expr '-' Expr {(Tree) {3, $1, $2, $3};}
 | Expr '*' Expr {(Tree) {3, $1, $2, $3};}
 | Expr '/' Expr {(Tree) {3, $1, $2, $3};}
 | NEW Identifier '(' LOptParam ')' {(Tree) {3, $1, $2, $4};}
 | '+' Expr %prec unary {(Tree) {2, $1, $2};}
 | '-' Expr %prec unary {(Tree) {2, $1, $2};}
 | '(' Identifier Expr ')' {(Tree) {2, $2, $3};}
 | Identifier '.' Identifier {(Tree) {3, $1,$2, $3};}
 | Identifier '.' Identifier '(' LOptParam ')' {(Tree) {4, $1,$2, $3, $5};}
 | '(' Expr ')' {(Tree) {1, $2};}
 | Identifier {(Tree) {1, $1};}
 | Constante {(Tree) {1, $1};}
;

LOptParam : LParam {$1}
| {nullptr;}
;

LParam : Param ',' LParam {(Tree) {2, $1, $3};}
| Param {(Tree) {2, $1, nullptr};}
;

Param : Identifier 
;

/* ===== Identifier & Constante ===== */

Identifier : IDENTIFIER {$1;}
;

Constante : INTEGER {$1;}
;

%%

#ifdef BISON_ONLY

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <iostream>

int main(int argc, char **argv) {
	int fi;
	if ((fi = open(argv[1], O_RDONLY)) == -1) {
		std::cerr << "Erreur: fichier inaccessible " << argv[1] << std::endl;
		exit(1);
	}
	std::cout << "Fichier " << argv[1] << " chargÃ©: " << std::endl;
	close(0); dup(fi); close(fi);
	return yyparse();
}

#endif