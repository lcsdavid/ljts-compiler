%token ASSIGNEMENT CLASS DEF ELSE EXTENDS IS IF OBJECT OVERRIDE VAR RETURN THEN

%token <int> RELATIONAL_OPERATOR

%token <std::string> IDENTIFIER
%token <std::variant<int, double>> INTEGER

%{

#include "ljts-compiler.hpp"

extern "C" {
	int yylex();
}

void yyerror (char const *s) {
	fprintf (stderr, "%s\n", s);
}

%}

%right ASSIGNMENT
%right ELSE
%left RELATIONAL_OPERATOR
%left '+' '-'
%left '*' '/'
%nonassoc unary

%%
ProgrammeComplet : Programme '$'
;

Programme : LOptDecls Bloc
;

LOptDecls : LDecls
|
;

LDecls : Class ';' LDecls
| Object ';' LDecls
| Decls
;

Decls : Class
| Object
;

//LClass : Class ';' LClass
//;

//LObject : Object ';' LObject
//; 
//Déclaration

LOptParam : LParam
|
;

LParam : Param',' LParam
| Param
;

Param : id
;

LOptParamDecl : LParamDecl
|
;

LParamDecl : ParamDecl',' LParamDecl
| ParamDecl
;

ParamDecl : OptVar id ':' id
;

OptVar : VAR
|
;

id : IDENTIFIER;
//Classe

Class : CLASS id '('LOptParamDecl')' OptExtends IS '{'ClassDef'}'
;

OptExtends : EXTENDS id
|
;

ClassDef : LOptField ClassConstructor LOptMethod
;

ClassConstructor : DEF id '('LOptParamDecl')' OptSuper IS '{'Bloc'}'
;

OptSuper : id'('LOptParam')'
|
;
//Objet

Object : CLASS id IS '{'ObjectDef'}'
;

ObjectDef : LOptField ObjectConstructor LOptMethod
;

ObjectConstructor : DEF id IS '{'Bloc'}'
;
//Champ

LOptField : LField
|
;

LField : Field LField
| Field
;

Field : VAR id ':' id
;
//Méthodes

LOptMethod : LMethod
|
;

LMethod : Method LMethod
|Method
;

Method : OptOverride id '('LOptParamDecl')' MethodEnd
;

OptOverride : OVERRIDE
|
;

MethodEnd : id ASSIGNMENT Expr
| OptReturn IS Bloc
;

OptReturn : id
|
;
//Instruction

Bloc : '{'LOptInst'}'
| '{'LOptVarDecl IS LInst'}'
;

LOptInst : LInst
|
;

LInst : Inst ';' LInst
| Inst ';'
;

Inst : Expr ';'
|Bloc
|RETURN ';'
|Expr ASSIGNMENT Expr ';'
|IF Expr THEN Inst ELSE Inst
;

LOptVarDecl : LVarDecl
|
;

LVarDecl : VarDecl LVarDecl
| VarDecl
;

VarDecl : id '=' Expr
;
//Expression

Expr : Constante
| Expr RELATIONAL_OPERATOR Expr
| Expr '+' Expr 
| Expr '-' Expr 
| Expr '*' Expr 
| Expr '/' Expr 
| id 
| '(' Expr ')'
;

Constante : INTEGER
;

%%

int main(int argc, char **argv) {
	int fi;
	if ((fi = open(argv[1], O_RDONLY)) == -1) {
		std::cerr << "Erreur: fichier inaccessible " << argv[1] << std::endl;
		exit(1);
	}
	std::cout << "Fichier " << argv[1] << " chargé: " << std::endl;
	close(0); dup(fi); close(fi);
	return yyparse();
}