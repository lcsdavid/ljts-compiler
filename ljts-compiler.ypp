/* Tokens placés en ordre alphabétique pour mieux si retrouver. */
%token ASSIGNMENT CLASS
%token DEF ELSE EXTENDS
%token <std::string> IDENTIFIER 
%token IF
%token <int> INTEGER
%token IS NEW OBJECT OVERRIDE
%token <int> RELATIONAL_OPERATOR
%token RETURN
%token <std::string> STRING
%token THEN 
%token <std::string> TYPENAME
%token VAR

%type <Program*> Programme

/* Declarations */
%type <std::vector<Type*>*> LOptDecls
%type <std::vector<Type*>> LDecls
%type <Type*> Decl

/* Parameters */
%type <std::vector<Parameter>*> LOptParamDecl
%type <std::vector<Parameter>> LParamDecl
%type <Parameter> ParamDecl
%type <bool> OptVar

/* Classes */
%type <Class*> ClassDecl
%type <std::string*> OptExtends

/* Objects */
%type <Object*> ObjectDecl

%type <std::tuple<std::vector<Variable>*, Constructor&, std::vector<Method>*> ClassDef ObjectDef

/* Fields */
%type <std::vector<Variable>*> LOptField
%type <std::vector<Variable>> LField
%type <Variable> Field

/* Constructors */
%type <ClassConstructor> ClassConstructor
%type <Constructor> ObjectConstructor

/* Methods */
%type <std::vector<Method>*> LOptMethod
%type <std::vector<Method>> LMethod
%type <Method> Method
%type <bool> OptOverride
%type <std::string*> OptReturn

/* Instructions */
%type <std::vector<Tree>*> LOptInst
%type <std::vector<Tree>> LInst
%type <Tree> Inst

%{

#define YYDEBUG 1

#include "ljts-compiler.hpp"

Program* program = nullptr;

%}
%debug
%error-verbose

%right ASSIGNMENT
%right ELSE
%left RELATIONAL_OPERATOR
%left '+' '-'
%left '*' '/'
%nonassoc unary NEW
%left '.'

%%
Programme : LOptDecls Bloc                                                             { program = new Program($1, $2); }
;

LOptDecls : LDecls                                                                     { $$ = new std::vector<Type*>(); $$->insert(std::end(*$$), std::begin($1), std::end($1); }
 |                                                                                     { $$ = nullptr; }
;

LDecls : Decl LDecls                                                                   { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2); }
 | Decl                                                                                { $$.push_back($1); }
;

Decl : ClassDecl                                                                       { $$ = $1; }
 | ObjectDecl                                                                          { $$ = $1; }
;

/* Parameter declaration*/

LOptParamDecl : LParamDecl                                                             { $$ = new std::vector<Parameter*>(); $$->insert(std::end(*$$), std::begin($1), std::end($1); }
 |                                                                                     { $$ = nullptr; }
;

LParamDecl : ParamDecl ',' LParamDecl                                                  { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2); }
 | ParamDecl                                                                           { $$.push_back($1); }	
;

ParamDecl : OptVar IDENTIFIER ':' TYPENAME                                             { $$ = Parameter($1, $2, $3); }
;

OptVar : VAR                                                                           { $$ = true; }
 |                                                                                     { $$ = false; }
;

/* ===== Class ===== */

ClassDecl : CLASS TYPENAME '(' LOptParamDecl ')' OptExtends IS '{' ClassDef '}'        { $$ = new Class($2, $4, $6, std::get<0>($9), std::get<1>($9), std::get<2>($9)); }
;

OptExtends : EXTENDS TYPENAME                                                          { $$ = new std::string($2); }
 |                                                                                     { $$ = nullptr; }
;

ClassDef : LOptField ClassConstructor LOptMethod                                       { $$ = std::make_tuple($1, $2, $3); }
;

ClassConstructor : DEF TYPENAME '(' LOptParamDecl ')' OptSuper IS Bloc                 { $$ = Constructor($2, $4, $6, $8); }
;

OptSuper : ':' TYPENAME '(' LOptParam ')'                                              { $$ = new Constructor($2, $4, nullptr); }
 |
;

/* ===== Object ===== */

ObjectDecl : OBJECT TYPENAME IS '{' ObjectDef '}'                                      { $$ = new Object($2, std::get<0>($5), std::get<1>($5), std::get<2>($5)); }
;

ObjectDef : LOptField ObjectConstructor LOptMethod                                     { $$ = std::make_tuple($1, $2, $3); }
;

ObjectConstructor : DEF TYPENAME IS Bloc                                               { $$ = Constructor($2, std::vector<Parameter*>(), nullptr, $4); }
;

/* ===== Champ ===== */

LOptField : LField                                                                     { $$ = new std::vector<Variable>($1); }
|                                                                                      { $$ = nullptr; }
;

LField : Field LField                                                                  { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
| Field                                                                                { $$.push_back($1); }  
;

Field : VAR IDENTIFIER ':' TYPENAME ';'                                                { $$ = Field($2, $4); }
;

/* ===== Method ===== */

LOptMethod : LMethod                                                                   { $$ = new std::vector<Method>($1); }
 |                                                                                     { $$ = nullptr; }
;

LMethod : Method LMethod                                                               { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
 | Method                                                                              { $$.push_back($1); }
;

Method : OptOverride DEF IDENTIFIER '(' LOptParamDecl ')' ':' TYPENAME ASSIGNMENT Expr { $$ = Method($1, $3, $5, $8, $10); } // TODO faire mieux eXPR
 | OptOverride DEF IDENTIFIER '(' LOptParamDecl ')' OptReturn IS Bloc                  { $$ = Method($1, $3, $5, $8, $10); }
;

OptOverride : OVERRIDE                                                                 { $$ = true; }
 |                                                                                     { $$ = false; }
;

OptReturn : ':' TYPENAME                                                               { $$ = new std::string($2); }
 |                                                                                     { $$ = nullptr; }
;

/* ===== Instruction ===== */

LOptInst : LInst                                                                       { $$ = new std::vector<Tree>($1); }
 |                                                                                     { $$ = nullptr; }
;

LInst : Inst LInst                                                                     { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); }
 | Inst                                                                                { $$.push_back($1); }
;

Inst : Expr ';'                                                                        { $$ = $1; }
 | Bloc                                                                                { /* TODO BLOC */ }
 | RETURN ';'                                                                          { $$ = Tree(/* return op code */); }
 | Expr ASSIGNMENT Expr ';'                                                            { $$ = Tree(assignement, $1, $3); }
 | IF Expr THEN Inst ELSE Inst                                                         { $$ = Tree(if_then_else, $2, $4, $6); }
;

Bloc : '{' LOptInst '}'                                                                { /* BLOC ? */ }
 | '{' LOptVarDecl IS LInst '}'                                                        { /* BLOC ? */ }
;

/* Declaration variable */

LOptVarDecl : LVarDecl                                                                 { $$ = new std::vector<Variable>($1); }
 |                                                                                     { $$ = nulltpr; }
;

LVarDecl : VarDecl LVarDecl                                                            { $$.push_back($1); $$.insert(std::end($$), std::begin($2), std::end($2)); 
 | VarDecl                                                                             { $$.push_back($1); }
;

VarDecl : IDENTIFIER ':' TYPENAME ASSIGNMENT Expr ';'                                  { $$ = Variable($1, $3, $5); } 
 | IDENTIFIER ':' TYPENAME ';'                                                         { $$ = Variable($1, $3); }
;

/* ===== Expression ===== */

Expr : Expr RELATIONAL_OPERATOR Expr                                                   { $$ = Tree(/*yylineno,*/ $2, $1, $3); }
 | Expr '+' Expr                                                                       { $$ = Tree(/*yylineno,*/ addition, $1, $3); } 
 | Expr '-' Expr                                                                       { $$ = Tree(/*yylineno,*/ substration, $1, $3); } 
 | Expr '*' Expr                                                                       { $$ = Tree(/*yylineno,*/ multiplication, $1, $3); }
 | Expr '/' Expr                                                                       { $$ = Tree(/*yylineno,*/ division, $1, $3); }
 | NEW TYPENAME '(' LOptParam ')'                                                      { $$ = Tree(/*yylineno,*/ instanciation, $2, $4);}
 | '+' Expr %prec unary                                                                { $$ = Tree(/*yylineno,*/ unary_plus, $2); }
 | '-' Expr %prec unary                                                                { $$ = Tree(/*yylineno,*/ unary_substract, $2); }
 | '(' TYPENAME Expr ')'                                                               { $$ = Tree(/*yylineno,*/ cast, $2, $3); }
 | Expr '.' IDENTIFIER                                                                 { $$ = Tree(/*yylineno,*/ member_access, $1, $3); }
 | TYPENAME '.' IDENTIFIER                                                             { $$ = Tree(/*yylineno,*/ member_access, $1, $3); }
 | Expr '.' IDENTIFIER '(' LOptParam ')'                                               { $$ = Tree(/*yylineno,*/ method_call, $1, $3, $5); }
 | TYPENAME '.' IDENTIFIER '(' LOptParam ')'                                           { $$ = Tree(/*yylineno,*/ method_call, $1, $3, $5); }
 | '(' Expr ')'                                                                        { $$ = Tree(/*yylineno,*/ $2); }
 | INTEGER                                                                             { $$ = Tree(/*yylineno,*/ , $1); }
 | STRING                                                                              { $$ = Tree(/*yylineno,*/ 272, $1); }
 | IDENTIFIER                                                                          { $$ = Tree(/*yylineno,*/ 263, $1); }
;;


LOptParam : LParam   // { $$ = $1 }
|                    // { $$ = nullptr; }
;

LParam : Param ',' LParam   // { $$ = (Tree) {lineo, 2, $1, $3};}
| Param                     // { $$ = (Tree) {lineo, 2, $1, nullptr}; }
;

Param : Expr
;

%%

#ifdef BISON_MAIN

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <iostream>

int main(int argc, char **argv) {
	int fi;
	if ((fi = open(argv[1], O_RDONLY)) == -1) {
		std::cerr << "Erreur: fichier inaccessible " << argv[1] << std::endl;
		exit(1);
	}
	std::cout << "Fichier " << argv[1] << " chargé correctement." << std::endl;
	close(0); dup(fi); close(fi);
	if (yyparse() == 0) {
		std::cout << "Compilation succeed!" << std::endl;
		return 0;
	}
	return -1;
}

#endif