/* Tokens placés en ordre alphabétique pour mieux si retrouver. */
%token ASSIGNMENT CLASS
%token DEF ELSE EXTENDS
%token <std::string> IDENTIFIER 
%token IF
%token <int> INTEGER
%token IS NEW OBJECT OVERRIDE
%token <int> RELATIONAL_OPERATOR
%token RETURN
%token <std::string> STRING
%token THEN 
%token <std::string> TYPENAME
%token VAR

%{

#define YYDEBUG 1

#include "ljts-compiler.hpp"

extern "C" int yylex();

extern "C" int yylineno;
extern "C" char* yytext;


void yyerror (char const *s) {
	fprintf (stderr, "Error: %s '$undefined = %s' at line %d\n", s, yytext, yylineno);
	exit(1);
}

%}
%debug
%error-verbose

%right ASSIGNMENT
%right ELSE
%left RELATIONAL_OPERATOR
%left '+' '-'
%left '*' '/'
%nonassoc unary NEW
%left '.'

%%
Programme : LOptDecls Bloc
;

LOptDecls : LDecls
 |
;

LDecls : Decls LDecls
 | Decls
;

Decls : ClassDecl
 | ObjectDecl
;

/*
LClassDecl : ClassDecl ';' LClassDecl
;

LObjectDecl : ObjectDecl ';' LObjectDecl
;
*/ 

/* Parameter declaration*/

LOptParamDecl : LParamDecl
 |
;

LParamDecl : ParamDecl ',' LParamDecl
 | ParamDecl
;

ParamDecl : OptVar Identifier ':' TYPENAME
;

OptVar : VAR
 |
;

/* ===== Class ===== */

ClassDecl : CLASS TYPENAME '(' LOptParamDecl ')' OptExtends IS '{' ClassDef '}'
;

OptExtends : EXTENDS TYPENAME
 |
;

ClassDef : LOptField ClassConstructor LOptMethod
;

ClassConstructor : DEF TYPENAME '(' LOptParamDecl ')' OptSuper IS Bloc
;

OptSuper : ':' TYPENAME '(' LOptParam ')'
 |
;

/* ===== Object ===== */

ObjectDecl : OBJECT TYPENAME IS '{' ObjectDef '}'
;

ObjectDef : LOptField ObjectConstructor LOptMethod
;

ObjectConstructor : DEF TYPENAME IS Bloc
;

/* ===== Champ ===== */

LOptField : LField
|
;

LField : Field LField
| Field
;

Field : VAR Identifier ':' TYPENAME ';'
;

/* ===== Method ===== */

LOptMethod : LMethod
 |
;

LMethod : Method LMethod
 | Method
;

Method : OptOverride DEF Identifier '(' LOptParamDecl ')' ':' TYPENAME ASSIGNMENT Expr
 | OptOverride DEF Identifier '(' LOptParamDecl ')' OptReturn IS Bloc
;

OptOverride : OVERRIDE
 |
;

OptReturn : ':' TYPENAME
 |
;

/* ===== Instruction ===== */

LOptInst : LInst
 |
;

LInst : Inst LInst
 | Inst
;

Inst : Expr ';'
 | Bloc
 | RETURN ';'
 | Expr ASSIGNMENT Expr ';'
 | IF Expr THEN Inst ELSE Inst
;

Bloc : '{' LOptInst '}'
 | '{' LOptVarDecl IS LInst '}'
;

/* Declaration variable */

LOptVarDecl : LVarDecl
 |
;

LVarDecl : VarDecl LVarDecl
 | VarDecl
;

VarDecl : Identifier ':' TYPENAME ASSIGNMENT Expr ';'
 | Identifier ':' TYPENAME ';'
;

/* ===== Expression ===== */

Expr : Expr RELATIONAL_OPERATOR Expr
 | Expr '+' Expr 
 | Expr '-' Expr 
 | Expr '*' Expr 
 | Expr '/' Expr 
 | NEW TYPENAME '(' LOptParam ')'
 | '+' Expr %prec unary
 | '-' Expr %prec unary
 | '(' TYPENAME Expr ')'
 | Expr '.' IDENTIFIER
 | TYPENAME '.' IDENTIFIER
 | Expr '.' IDENTIFIER '(' LOptParam ')'
 | TYPENAME '.' IDENTIFIER '(' LOptParam ')'
 | '(' Expr ')'
 | INTEGER
 | STRING
 | IDENTIFIER
;

LOptParam : LParam
|
;

LParam : Param ',' LParam
| Param
;

Param : Expr
;

/* ===== Identifier & Constante ===== */

Identifier : IDENTIFIER
;

%%

#ifdef BISON_MAIN

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <iostream>

int main(int argc, char **argv) {
	int fi;
	if ((fi = open(argv[1], O_RDONLY)) == -1) {
		std::cerr << "Erreur: fichier inaccessible " << argv[1] << std::endl;
		exit(1);
	}
	std::cout << "Fichier " << argv[1] << " chargé: " << std::endl;
	close(0); dup(fi); close(fi);
	return yyparse();
}

#endif