 \documentclass[12pt,a4paper]{article}

\usepackage{lmodern}
\usepackage[utf8]{inputenc}

\usepackage[top=20mm,bottom=20mm,left=18mm,right=18mm]{geometry}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{array}
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{multicol}
\usepackage{parskip}

\definecolor{blue}{HTML}{000080}
\definecolor{turquoise}{HTML}{008080}

\lstset{
	language=c++,
	frame=shadowbox,
	framexleftmargin=2em,
	backgroundcolor=\color[HTML]{2B2B2B},
	columns=fullflexible,
	basicstyle=\color{white}\ttfamily\small,
	commentstyle=\color{gray},
	stringstyle=\color{green},
	keywordstyle=\color[HTML]{CC7832},
	showstringspaces=true,
	numbers=left,
	numberfirstline=true,
	numberstyle=\color{white}\ttfamily\small,
	tabsize=4,
	literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
	{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
	{À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
	{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
	{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
	{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
	{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
	{Ã}{{\~A}}1 {ã}{{\~a}}1 {Õ}{{\~O}}1 {õ}{{\~o}}1
	{œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
	{ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
	{ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
	{€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
	{»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

\begin{document}
\title{\bfseries Projet de Compilation}
\author{Lucas David, Sullivan Honnet, Théo Legras \& Jules Vittone}
\date{}
\maketitle

\part{Analyse lexicale}

Premièrement, nous pouvons définir des expressions régulières intermédiaires qui nous seront utiles pour éviter les expressions trop complexes:

\begin{tabular}{l}
    \verb!{digit}!   = \verb![0-9]!        \tabularnewline
    \verb!{letter}!  = \verb![A-Za-z0-9_]! \tabularnewline
    \verb!{newline}! = \verb![(\r\n?)|\n]! \tabularnewline
\end{tabular}

Dans un second temps, nous ne traitons pas le commentaire comme un token mais nous le reconnaissons pour pouvoir l'éliminer de l'analyse:

\begin{tabular}{l}
\verb!{commentary}! = \verb!\/{2}[^{newline}]*{newline}|\/\*([^\*]*|\*[^\/])*\*\/!
\end{tabular}


Et finalement, pour définir comment s'organise le projet de compilation, il faut réfléchir aux tokens que nous allons reconnaître. Aussi, pour chacun des tokens reconnu le nombre de caractère devra être compté pour garder un contexte d'erreur lors de la compilation. En voici, un exemple d'approche:

Pour cela, nous indiquons l'option \texttt{--yylineno} lors de l'appel de \texttt{flex}, qui indiqué à flex d'incrémenter la valeur de \texttt{yylineno} à chaque saut de ligne.

\newpage

Finalement, voici le tableau des différents tokens reconnus ainsi que leurs expressions régulières et types retournés respectifs (à noter que $\varnothing$ signifie que le token ne retourne pas de valeur):

\begin{center}
	\sffamily
	\begin{tabular}{|c|c|c|}
		\hline
		Token & Expression régulière & Type du token \tabularnewline
		\hline \hline
		\multicolumn{3}{|c|}{Mots clés réservés} \tabularnewline		
		\hline
		\textbf{CLASS}    & \verb|class|    & $\varnothing$ \tabularnewline
		\hline
		\textbf{DEF}      & \verb|def|      & $\varnothing$ \tabularnewline
		\hline
		\textbf{ELSE}     &  \verb|else|    & $\varnothing$ \tabularnewline
		\hline
		\textbf{EXTENDS}  & \verb|extends|  & $\varnothing$ \tabularnewline
		\hline
		\textbf{IS}       & \verb|is|       & $\varnothing$ \tabularnewline
		\hline
		\textbf{IF}       & \verb|if|       & $\varnothing$ \tabularnewline
		\hline
		\textbf{OBJECT}   & \verb|object|   & $\varnothing$ \tabularnewline
		\hline
		\textbf{OVERRIDE} & \verb|override| & $\varnothing$ \tabularnewline
		\hline
		\textbf{VAR}      & \verb|var|      & $\varnothing$ \tabularnewline
		\hline
		\textbf{RETURN}   & \verb|return|   & $\varnothing$ \tabularnewline
		\hline
		\textbf{THEN}     & \verb|then|     & $\varnothing$ \tabularnewline
		\hline \hline
		\multicolumn{3}{|c|}{Opérateurs arithmétiques} \tabularnewline
		\hline
		\verb|'+'| & \verb|\+| & $\varnothing$ \tabularnewline
		\verb|'-'| & \verb|-|  & $\varnothing$ \tabularnewline
		\verb|'*'| & \verb|\*| & $\varnothing$ \tabularnewline
		\verb|'/'| & \verb|\/| & $\varnothing$ \tabularnewline
		\hline \hline
		\multicolumn{3}{|c|}{Opérateurs relationnels} \tabularnewline
		\hline
		\textbf{RELATIONAL\_OPERATOR} & \verb!<|<=|>=|=|<>! & {\color{blue}int} \tabularnewline
		\hline \hline
		\multicolumn{3}{|c|}{Autres opérateurs} \tabularnewline
		\hline
		\textbf{ASSIGNMENT}     & \verb|:=| & $\varnothing$ \tabularnewline
		\verb|'.'| & \verb|\.|  & $\varnothing$ \tabularnewline
		\hline \hline
		\multicolumn{3}{|c|}{Idenifiants \& constantes} \tabularnewline
		\hline
		\textbf{IDENTIFIER} & \verb/{letter}({letter}|{digit})*/ & {\color{blue}class} {\color{turquoise}std}::{\color{turquoise}string} \tabularnewline
		\textbf{STRING}     & \verb|"[^"]*"|                     & {\color{blue}class} {\color{turquoise}std}::{\color{turquoise}string} \tabularnewline
		\textbf{CHAR}       & \verb|'[^']+'|             & {\color{blue}char}   \tabularnewline		
		\textbf{INTEGER}    & \verb|{digit}+|            & {\color{blue}int}    \tabularnewline
		\textbf{DOUBLE}     & \verb|{integer}\.{digit}*| & {\color{blue}double} \tabularnewline
		\hline
	\end{tabular}
\end{center}

On peut en déduire l'{\color{blue}enum} suivante (extrait du fichier \href{../yytokentype.hpp}{\ttfamily yytokentype.hpp}), qui servira dans le fonctionnement de \texttt{bison}:
\begin{lstlisting}
enum yytokentype {
	ASSIGNMENT = 258, CLASS = 259,
	DEF = 260, ELSE = 261,
	EXTENDS = 262, IDENTIFIER = 263,
	IF = 264, INTEGER = 265,
	IS = 266, NEW = 267,
	OBJECT = 268, OVERRIDE = 269,
	RELATIONAL_OPERATOR = 270, RETURN = 271,
	STRING = 272, THEN = 273,
	THIS = 274, TYPENAME = 275,
	VAR = 276, unary = 277
};
\end{lstlisting}


\newpage

\part{Analyse syntaxique}

\section{Grammaire}

\subsection{Programme}

{\sffamily
Program :=  LOptDecls Block \$

LOptDecls := LDecls \textbar \ $\varepsilon$ \newline
LDecls := Decl LDecls \textbar \ Decl \newline
Decl := Class \textbar \ Object \newline
}


\subsection{Déclarations}



\subsubsection{Déclaration d'une classe}

{\sffamily
Class := \textbf{CLASS TYPENAME} \verb|'('| LOptParamDecl \verb|')'| OptExtends \textbf{IS} \verb|'{'| LOptField ClassConstructor LOptMethod \verb|'}'| \newline
OptExtends := \textbf{EXTENDS TYPENAME} \textbar \ $\varepsilon$

{\sffamily
LOptParamDecl := LParamDecl \textbar \ $\varepsilon$ \newline
LParamDecl := ParamDecl \verb|,| LParamDecl \textbar \ ParamDecl \newline
ParamDecl := OptVar \textbf{IDENTIFIER} \verb|:| \textbf{TYPENAME} \newline
OptVar := \textbf{VAR} \textbar \ $\varepsilon$
}

ClassConstructor := \textbf{DEF TYPENAME} \verb|'('| LOptParamDecl \verb|')'| \verb|':'| \textbf{TYPENAME} \verb|'('| LOptExpr \verb|')'| \textbf{IS Block} \textbar \ \textbf{DEF TYPENAME} \verb|'('| LOptParamDecl \verb|')'| \textbf{IS} Block
}

\subsection{Déclaration d'un objet}

{\sffamily
Object := \textbf{OBJECT TYPENAME} \textbf{IS} \verb|'{'| LOptField ObjectConstructor LOptMethod \verb|}|

ObjectConstruct := \textbf{DEF IDENTIFIER IS} \verb|'{'| Bloc \verb|'}'|
}

\subsection{Déclaration d'un champ}

{\sffamily
LOptField := LField \textbar \ $\varepsilon$ \newline
LField := Field LField \textbar \ Field \newline
Field := \textbf{VAR IDENTIFIER} \verb|':'| \textbf{TYPENAME} \verb|';'|
}

\subsection{Déclaration d'une méthode}

{\sffamily\small
LOptMethod := LMethod \textbar \ $\varepsilon$ \newline
LMethod := Method LMethod \textbar \ Method \newline
Method := OptOverride \textbf{IDENTIFIER} \verb|'('| LOptParamDecl \verb|')'| \verb|':'| \textbf{IDENTIFIER ASSIGNMENT} Expr \newline
\textbar \ OptOverride \textbf{IDENTIFIER} \verb|'('| LOptParamDecl \verb|')'| OptReturn \textbf{IS} Bloc \newline
OptOverride := \textbf{OVERRIDE} \textbar \ $\varepsilon$ \newline
OptReturn := \verb|':'| \textbf{IDENTIFIER} \textbar \ $\varepsilon$
}

\subsection{Expressions et instructions}

\subsubsection{Expressions}

On connait le principe pour faire apparaitre la priorité et l'associativité des opérateurs mais vu que Bison l'intègre "en dehors" de la définition des règles on va faire de même (pour consulter notre liste la priorité et l'associativité des opérateurs, autant directement consulter celle du C++: \url{https://en.cppreference.com/w/cpp/language/operator_precedence}).

{\sffamily
\begin{tabular}{rcl}
    Expr  & := & Expr \textbf{RELATIONAL\_OPERATOR} Expr                         \tabularnewline
    & \textbar & Expr \textbf{'+'} Expr                                         \tabularnewline
    & \textbar & Expr \textbf{'$-$'} Expr                                        \tabularnewline
    & \textbar & Expr \textbf{'*'} Expr                                     \tabularnewline
    & \textbar & Expr \textbf{'/'} Expr                                       \tabularnewline
    & \textbar & \textbf{NEW} \textbf{IDENTIFIER} \verb|(| LOptParam \verb|)|    \tabularnewline
    & \textbar & \textbf{'+'} Expr                                              \tabularnewline
    & \textbar & \textbf{'$-$'} Expr                                             \tabularnewline
    & \textbar & \verb|(| \textbf{IDENTIFIER} Expr \verb|)|                      \tabularnewline
    & \textbar & \textbf{IDENTIFIER} \textbf{'\texttt{.}'} \textbf{IDENTIFIER} \tabularnewline
    & \textbar & \textbf{IDENTIFIER} \textbf{'\texttt{.}'} \textbf{IDENTIFIER} \verb|(| LOptParam \verb|)| \tabularnewline
    & \textbar & \verb|(| Expr \verb|)| \tabularnewline
    & \textbar & \textbf{IDENTIFIER}    \tabularnewline
    & \textbar & \textbf{INTEGER}       \tabularnewline
    & \textbar & \textbf{STRING}        \tabularnewline
\end{tabular}}

\subsubsection{Instructions}

    {\sffamily
    \begin{tabular}{rcl}
        Instr & := & Expr \verb|;| \tabularnewline
        & \textbar & Bloc          \tabularnewline
        & \textbar & \textbf{RETURN} \verb|;|      \tabularnewline
        & \textbar & Expr \textbf{ASSIGNMENT} Expr \verb|;|                   \tabularnewline
        & \textbar & \textbf{IF} Expr \textbf{THEN} Instr \textbf{ELSE} Instr \tabularnewline
    \end{tabular}}

{\sffamily
    \begin{tabular}{rcl}
        Bloc        & := & \verb|{| LOptInst \verb|}|                      \tabularnewline
              & \textbar & \verb|{| LOptVarDecl \textbf{IS} LInst \verb|}| \tabularnewline
        LOptVarDecl & := & LVarDecl         \tabularnewline
              & \textbar & $\varepsilon$    \tabularnewline
        LVarDecl    & := & VarDecl LVarDecl \tabularnewline
              & \textbar & VarDecl          \tabularnewline
        VarDecl     & := & \textbf{IDENTIFIER} \verb|:| \textbf{IDENTIFIER} Expr \verb|;| \tabularnewline
              & \textbar & \textbf{IDENTIFIER} \verb|:| \textbf{IDENTIFIER} \verb|;| \tabularnewline    
    \end{tabular}}

\end{document}